User Guide
============

This document explains the concepts and usage of Knitfab to Knitfab users.

The section explaining the concept is useful for anyone involved with Knitfab to understand the basic ideas.
The other chapters are specifically written for users who want to perform machine learning tasks on Knitfab.

他言語版/Translations
---------------------

- 日本語: [./user-guide.ja.md](./user-guide.ja.md)

Concept of Knitfab
--------

Knitfab is
- a MLOps tool which has
- an automatic lineage management feature
- with a tag-based workflow engine

Workflow Engine automatically executes the necessary tasks according to the user-defined plan.
The automatic lineage management feature automatically records the history of all data generated by Knitfab by tracking the relationship between each task and its inputs and outputs during the execution of the tasks.

### Machine Learning Tasks

In Knitfab, all machine learning tasks (including general processes) are abstracted as "taking inputs and producing outputs".
This means that almost any program can be used as a machine learning task.

However, machine learning tasks have the following constraints:

- Inputs are read from the file system (directories).
- Outputs are written to standard output/error or to the file system (directories).
- They are packaged as container images (Docker images).

For example, a program that reads training data from one directory and training hyperparameters from another directory (these are inputs), and writes the model to one directory and training metrics to another directory (these are outputs), would be suitable as a machine learning task in Knitfab.

### Tag

Tag can be assigned to resources managed by Knitfab.
Tag is metadata that take the form of key-value pairs and can generally be freely set.

For example, consider the following Tags:

- `project: some-project`: Indicates that the resource is related to a specific project.
- `type: dataset`: Indicates that the Data is a dataset of some kind.
- `format: mnist`: Indicates that the Data is formatted in the MNIST format.
- `mode: train`: Indicates that the Data is intended for training purposes.

If a set of Tags like these is attached to a piece of data, it is likely to be the training dataset for MNIST.

In all cases, the key of the Tag is everything before the first `:`, and the value is everything after.

There are some constraints on the Tag keys:

- The character `:` cannot be used.
- Keys starting with `knit#` are reserved by Knitfab (known as "System Tag") and cannot be set by users.

### Data

Data refers to the input and output of machine learning tasks. Data is organized by directories.
Of course, Data generated as output by one machine learning task can be used as input by other machine learning tasks.

Data can be put Tags. The Tags associated with the Data are metadata that describe "What is this Data?" and "What are its characteristics?"

Once Data is created, it remains immutable, meaning its content cannot be changed except for its Tags.

### Plan

A Plan is a definition of a machine learning task. It specifies:

- What processing to perform
- What Data to assign as input to which file paths
- Which file paths are outputs and what kind of Data they represent

A Plan is defined using the following YAML format:

```yaml
image: "localhost:30503/Knitfab-first-validation:v1.0"

inputs:
  - path: "/in/dataset"
    tags:
      - "type:dataset"
      - "mode:test"
      - "project:some-project"
  - path: "/in/model"
    tags:
      - "type:model"
      - "framework:pytorch"
      - "project:some-project"

outputs:
  - path: "/out/metrics"
    tags:
      - "type:csv"
      - "project:some-project"

log:
  tags:
    - "type:log"
    - "project:some-project"
    - "type:text"
```

- `image`: Specifies the content of the processing as a container image.
- `inputs`, `outputs`: Indicates the inputs and outputs.
    - Tags are specified for file paths.
- `log`: Records the standard output and standard error generated by the machine learning task as Data.
    - Since this is also a type of output, can be put Tags.

The Tags for inputs indicate "What kind of Data can be assigned to this input?"
The Data assigned by Knitfab to a certain input must have all the Tags specified for that input.

The Tags for outputs indicate "What Tags should be assigned to the Data written to this output?"
When the machine learning task is executed, the output Data is newly created, and the initial Tags set at that time are specified as the Tags for the output.

### Runs and Lineage

A Run is a record of an executed machine learning task. A Run is derived based on a Plan and Data.

When Knitfab detects that a certain Data can be assigned as input for each Plan, it automatically generates a Run from the combination of inputs and Data.

For a given Plan, there may be multiple possible Data assignments for inputs.
For example, taking the example shown in the Plan section, if there are two possible Data (evaluation dataset) that can be set for `/in/dataset` and three possible Data (trained model) that can be set for `/in/model`, Knitfab will generate and execute a total of $2 \times 3 = 6$ Runs.

A Run consists of specific input Data, output Data, and information about the Plan that the Run is based on.
It is simply a record of "What was inputted and outputted for a specific machine learning task", representing one step of lineage.
Knitfab represents lineage as a chain of dependencies between Runs and Data.

CLI Tool: knit
-----------------

Knitfab users perform operations on Knitfab using the CLI command `knit`.

Instructions on how to obtain the CLI tool can be found in the getting-started section.

### Subcommands

`knit` has subcommands based on the concepts it handles.

- `knit data`: Commands for manipulating Data
    - Example: `knit data pull`: Download the Data recorded in Knitfab.
- `knit plan`: Commands for manipulating Plans
    - Example: `knit plan apply`: Register a Plan in Knitfab.
- `knit run`: Commands for manipulating Runs
    - Example: `knit run find`: Search for Runs.

There are also additional subcommands for management purposes. They will be introduced as needed when explaining specific tasks.

Connecting to the cluster, managing projects
-----------------------------------

Knitfab is a client-server system.
The CLI `knit` sends requests to the Knitfab server, and the actual processing is performed on the server side.

Before using the `knit` command, the connection settings are required.

### Handout

To use Knitfab, please obtain a set of configuration files called a "handout" from the Knitfab administrator (installer).

The handout is generated when Knitfab is installed and contains the necessary information to connect to Knitfab.

### (Required) Connecting to Knitfab

To connect to Knitfab, you need to register a connection profile (knitprofile) with the `knit` command.
The connection profile is included in the handout.

Next, when you use the following command

```
knit init path/to/handout/knitprofile
```

the specified knitprofile will be imported into your profile store. The profile store is located at ~/.knit/profile by default.

Now, the knit command will be able to connect to Knitfab.

### (Required; on-prem) Trusting Knitfab in Docker

Knitfab has a private container image registry within the cluster. With this, you can register their own images as machine learning tasks that can only be used by Knitfab.

However, when using this cluster image registry, it is necessary to trust its TLS certificate in your docker environment.

There is a directory called `docker/certs.d` in the handout. Incorporate its contents into your docker configuration.

**For Linux-like environments:**

> [!Note]
>
> This pattern includes scenarios where dockerd is running on a Linux virtual machine on physical machines such as Windows or MacOS (e.g., docker-machine, colima, minikube).
>
> In this case, the certificate needs to be placed inside the `/etc/docker/certs.d` directory on the virtual machine.
>

```
cp -r path/to/handout/docker/certs.d/* /etc/docker/certs.d/
```

In some cases, you may need to use `sudo`.

For more details, please refer to https://docs.docker.com/engine/security/certificates/ .

**For Windows environment with Docker Desktop**

```
cp -r path\to\handout\docker\certs.d/* %USERPROFILE%\docker\certs.d
```

After executing the above command, restart Docker Desktop.

For more details, please refer to https://docs.docker.com/desktop/faqs/windowsfaqs/#how-do-i-add-custom-ca-certificates and https://docs.docker.com/desktop/faqs/windowsfaqs/#how-do-i-add-client-certificates.

### (Optional) Sharing Project-Specific Settings

In a project using Knitfab, you can share default behaviors of certain commands with other team members.

By creating a configuration file called `knitenv`, its contents will be applied in the directory where the file exists or any of its subdirectories.

The `knitenv` file is a YAML file with the following structure.

```
tag:
    - project:some-project
resource:
    cpu: 1
    memory: 1Gi
```

The meanings of each key are as follows:

- `tag`: Tags that are commonly set for Data and Plan inputs and outputs (multiple tags can be set; default is empty)
    - In the example above, all registered Data and created Plans will automatically have the Tag `project:some-project` set.
- `resource`: Required computing resources for creating Plan definition templates.
    - In this example, the project defaults to using 1 CPU core and 1 GB of memory for processing this Plan.
    - More details about this item will be covered in the Plan Definition section.

This file is intended to be shared among your team.
If you are version controlling your machine learning project with git or similar tools, it is recommended to include this file in version control.

Managing Data
-----

Data refers to directories with tags that contain the results of machine learning tasks. Users can also create Data by registering it with Knitfab.

The created Data in Knitfab is compared with the inputs of each Plan and if there is an executable Plan, it is executed as a Run.

This chapter discusses the handling of this Data.

### Registering Data

When you want to use a collection of files, such as a dataset, as input for a machine learning task, you can register it as Data in Knitfab.

Do the following:

```
knit data push -t your:tag /path/to/data
```

By doing this, the directory `/path/to/data` will be uploaded to Knitfab and treated as Data in Knitfab.

The `-t` flag means that when uploading the Data, a Tag will also be set for the Data. In this example, the Tag `your:tag` will be set when registering the Data.

Even without providing the `-t` flag, the Tags specified in the `knitenv` file will be implicitly set.

After executing the command, the metadata of the registered Data will be displayed on the console, following the progress logs.

```json
{
    "knitId": "a0f5911d-5ac5-4035-8c91-9946b02adc70",
    "tags": [
        "knit#id:a0f5911d-5ac5-4035-8c91-9946b02adc70",
        "knit#timestamp:2024-03-06T09:25:16.586+00:00",
        "project:some-project",
        "your:tag"
    ],
    "upstream": {
        "path": "/upload",
        "tags": [],
        "run": {
            "runId": "a5c1106c-122f-416c-b4f4-e6dd03af212c",
            "status": "done",
            "updatedAt": "2024-03-06T09:25:16.586+00:00",
            "plan": {
                "planId": "fb9b7087-9fe7-43c3-9302-a35488c85ffb",
                "name": "knit#uploaded"
            }
        }
    },
    "downstreams": [],
    "nomination": []
}
```

- `knitId`: This is the ID that identifies this Data.
- `tags`: It shows the Tags that are set for this Data.
    - It includes automatically assigned system-generated Tags (with keys starting with `knit#`) and user-defined Tags.
    - Additionally, if there are any Tags set in `knitenv`, they will also be included.
- `upstream`: It shows the output where this Data was written and information about the corresponding Run.
    - In this case, it displays a Run of a special  Plan that accepts the upload of Data.
- `downstream`: It includes information about the Runs that use this Data (if any).
- `nomination`: It includes information about the inputs of the Plan to which this Data is assigned (if any).

#### Command Line Options

- `-t key:value`, `--tag key:value`: Set Tags for the registered Data.
- `-n`, `--name`: Set Tags based on the directory name.
    - The set Tag will be `name:${directory_name}`.
- `-L`, `--dereference`: Trace symlinks in the directory and register the target instead of the symlink.
    - Without this flag, symlinks will be registered as symlinks.
    - `knit` does not validate if the target is included in the Data.

### Check Data

#### Check Metadata

There may be times when you want to check the metadata of registered Data later on. For example:

- What Tags are currently set?
- What Plans could potentially use this Data as input?
- How has this Data been used as input for Runs?

To examine the metadata of such Data, use the following command.

```
knit data find -t knit#id:KNIT-ID
```

Replace `KNIT-ID` with the ID of the Data you are interested in.

The `knit data find` command is used to search for Data.

The `-t` flag is used to specify "having this Tag" as a search condition, and in this case, the value of the `knit#id:` Tag is specified as the ID of the Data. As a result, you can obtain metadata for a specific Data.

The following results will be returned.

```json
[
    {
        "knitId": "87038a1d-467c-45d4-9cc7-876473f3fc04",
        "tags": [
            "format:mnist",
            "knit#id:87038a1d-467c-45d4-9cc7-876473f3fc04",
            "knit#timestamp:2024-03-06T09:53:21.792+00:00",
            "mode:test",
            "name:qmnist-test",
            "project:first-Knitfab",
            "type:dataset"
        ],
        "upstream": {
            "path": "/upload",
            "tags": [],
            "run": {
                "runId": "71c4593b-449f-4843-a503-0cd44720d85e",
                "status": "done",
                "updatedAt": "2024-03-06T09:53:21.792+00:00",
                "plan": {
                    "planId": "fb9b7087-9fe7-43c3-9302-a35488c85ffb",
                    "name": "knit#uploaded"
                }
            }
        },
        "downstreams": [
            {
                "path": "/in/dataset",
                "tags": [
                    "mode:test",
                    "project:first-Knitfab",
                    "type:dataset"
                ],
                "run": {
                    "runId": "3cb1b091-01ad-41b1-acac-3f042f9df97c",
                    "status": "done",
                    "updatedAt": "2024-03-06T10:01:16.301+00:00",
                    "exit": {
                        "code": 0,
                        "message": "Completed"
                    },
                    "plan": {
                        "planId": "6dbfed46-f9fb-4e4e-aadd-2a5c42d26913",
                        "image": "localhost:30503/Knitfab-first-validation:v1.0"
                    }
                }
            }
        ],
        "nomination": [
            {
                "path": "/in/dataset",
                "tags": [
                    "mode:test",
                    "project:first-Knitfab",
                    "type:dataset"
                ],
                "plan": {
                    "planId": "6dbfed46-f9fb-4e4e-aadd-2a5c42d26913",
                    "image": "localhost:30503/Knitfab-first-validation:v1.0"
                }
            }
        ]
    }
]
```

The structure of each element is the same as described in the "Registering Data" section. In this example, since the Data has been used as input in other runs, the `downstreams` and `nomination` also contain the details.

##### Command-line options

- `-t key:value`, `--tag key:value`: Search for Data with the specified Tag.
    - If multiple Tags are specified, only the Data with all the Tags will be searched.

If `-t` is not specified at all, all Data will be shown.

#### Downloading the Data Itself

You can not only view metadata but also download the actual Data itself.

You may often want to download model parameters or evaluation results.

```
knit data pull -x KNIT_ID path/to/dest
```

This command writes the contents of the Data identified by the ID `KNIT_ID` to the directory `path/to/dest/${KNIT_ID}`.

##### Command-line options

- `-x`: Download and extract the Data.
    - If not specified, the Data"will be downloaded as a `tar.gz` compressed file to `path/to/dest/${KNIT_ID}.tar.gz`.

### Changing Data Tags

You can change the Tags of already registered Data.

For example,

- If there is a Tag `deployed:true` that indicates "deployed", you may want to move it to other Data.
- If you no longer want a certain Data to be used as input for a Run, you may want to remove the Tag.
- If you want to use a certain Data in a specific Plan, you may want to add the Tag.

This is useful in such cases.

To add Tag, you can use the following command:

```
knit data tag --add new:tag KNIT_ID
```

and This will add the "new:tag" Tag to the Data identified by the ID `KNIT_ID`.

In addition, executing

```
knit data tag --remove old:tag KNIT_ID
```

will removed the Tag `old:tag` from the Data identified by the ID `KNIT_ID`.
If you try to add a Tag that already exists in the Data or remove a Tag that doesn't exist, nothing will happen and no error will be thrown.

In this case, you cannot add or remove Tag that start with the key `knit#`. These tags are reserved and managed by the system.

#### Command-line options

- `--add key:value`: Add a Tag.
- `--remove key:value`: Remove a Tag.

Both options can be specified multiple times and will take effect for all specified Tags.
However, if `--add` and `--remove` are specified for the same Tag, `--remove` will take precedence.

### Data cannot be deleted

In Knitfab, it is not possible to directly delete specific Data.

However, if a Run is deleted, the output Data of that Run will also be deleted. Therefore, this method can be used if the Data is no longer needed.

For more details, please refer to the "Managing Runs" section.

Managing Plans
-----

A Plan is a definition of a machine learning task in Knitfab.

When you register a Plan in Knitfab, it calculates executable input patterns based on the definition and automatically generates Runs.

This chapter describes how to handle Plans.

### Registering a Plan Definition

To register a Plan in Knitfab, use the following command:

```
knit plan apply path/to/plan_definition.yaml
```

When you specify the Plan definition file `path/to/plan_definition.yaml`, Knitfab registers the Plan with its contents.

#### Describing the Plan Definition

The Plan definition file is a yaml file that focuses on "which image", "what inputs to assign", and "what outputs to obtain".

A **minimal** Plan definition file looks something like this:

```yaml
image: "localhost:30503/train:v1.0"

inputs:
  - path: "/in/dataset"
    tags:
      - "project:some-project"
      - "type:dataset"
      - "mode:train"
  - path: "/in/params"
    tags:
      - "project:some-project"
      - "type:hyper-params"
      - "format:yaml"

outputs:
  - path: "/out"
    tags:
      - "project:some-project"
      - "type:model"

logs:
  - "project:some-project"
  - "type:log"
```

- `image`: Specifies "which image" for the processing.
    - The container image name is specified with the tag.
        - The image name follows the structure of `[host:port/][repository/]name:tag`.
    - If you want to use an image registered in the Knitfab image registry,
        - Set the host to `localhost`.
        - The port is typically `30503` for a standard installation. Please check with the administrator who performed the installation for details.
- `inputs`: Specifies "what inputs" to assign.
    - Each input is a combination of `path` and `tags`. Multiple inputs can be specified.
        - In the example, there are two inputs: `/in/dataset` and `/in/params`.
    - For each input,
        - `path` indicates the directory in the container where the input is provided when executing this task.
        - `tags` indicate what Data can be assigned to this input.
            - You can specify "system Tags" such as `knit#id` and `knit#timestamp`. This can be useful if you want to do something specific after identifying the Data.
    - At least one input is required. And each input must have at least one "Tag" set.
- `outputs`: Specifies "what outputs" will be obtained.
    - This is also a combination of `path` and `tags`. Like `inputs`, multiple outputs can be specified.
    - For each output,
        - `path` indicates the directory in the container where the task output is written.
        - `tags` indicate the set of "Tags" that are automatically assigned when this output Data is created.
    - Outputs can be zero.
- `logs`: A special output that collects the logs (stdout and stderr) of the task and turns them into Data.
    - This is optional. If omitted, the logs of the Run based on this Plan will not be recorded and will be discarded.
    - `tags` are the same as `tags` in `outputs` and indicate the set of "Tags" automatically assigned to the written logs.

It is recommended to generate a template for the Plan definition file by executing the following command, rather than writing it manually:

```
knit plan template --scratch > template.plan.yaml
```

This command generates an empty template in `template.plan.yaml`.


Also, if you have already decided on the container image you want to use, you can generate a template that reflects the contents of that image with the following command:

```
docker save IMAGE_NAME:TAG | knit plan tempalte > IMAGE.TAG.plan.yaml
```

(`IMAGE_NAME:TAG` should be changed accordingly to the desired image)

Even when executing this command, it is necessary to review the contents of the Plan definition file and adjust it to meet the actual requirements.

In addition to what is shown here, there are optional attributes.

#### `active`

```yaml
active: true
```

Specifies the "active" status of the Plan. Only the Runs based on an "active" Plan will be actually executed. The default value is `true`.

There may be cases where you don't want the Runs based on the Plan to be executed immediately when registering that Plan.
In such cases, it is recommended to set `active: false` (inactive) in the Plan definition file and apply it using `knit plan apply`.


#### `resource`

```yaml
resources:
  cpu: 1
  memory: 1Gi
```

You can specify the limits of compute resources allocated to the Runs based on this Plan.
The default is 1 CPU core and 1 GiB of memory as mentioned above.
If `resources.cpu` or `resources.memory` are omitted, these default values will be applied.

Alternatively, if `resources` is defined in the `knitenv` file, it will be used instead of the default values.

If you need more resources, you can modify the settings. Decimal values are also allowed.
For example, if you anticipate needing 2.5 cores and 3.5 GiB of memory, you can specify it as follows:

```yaml
resources:
  cpu: 2.5
  memory: 3.5Gi
```


In addition, it is possible to describe the resource requirements for compute resources such as GPUs in the `resources` section.

```yaml
resources:
  cpu: 1
  memory: 1Gi
  nvidia.com/gpu: 1
```

The types of compute resources that can be specified other than `cpu` and `memory` depend on the underlying Kubernetes cluster that Knitfab is built on. Please check with your Knitfab administrator for the possible values that can be configured.

> **Advanced Note**
>
> This value will ultimately be used as `resources.limits` and `resources.requests` in the pod definition of Kubernetes.
>

#### on_node

There may be cases where you want to execute certain computational tasks on specific machines.

For example,

- Training tasks may need to be executed on machines with GPUs, while evaluation tasks may not.
- Tasks that are sufficiently handled by CPUs may want to avoid machines with GPUs and prioritize tasks that require valuable computational resources.

By setting appropriate values in `on_node`, you can restrict the placement of Runs for this Plan on specific machines.

```yaml
on_node:
  may:
    - "key=value"
  prefer:
    - "vram=large"
  must:
    - "accelarator=gpu"
```

`on_node.may`, `on_node.prefer`, and `on_node.must` all require an array of "labels" (`key=value`) to be specified.
These labels refer to the metadata labels of the machines.
For meaningful values, please consult the administrator who set up the Kubernetes cluster where Knitfab is installed.

Each item is optional, and if omitted, it is equivalent to not specifying any labels for that item.
If `on_node` itself is omitted, it is equivalent to having all items empty.

The meanings of each item are as follows:

- `may`:
    - Indicates that the task **may be executed** on a machine with that label.
    - Machines with that label are typically configured to not receive computational tasks.
- `prefer`:
    - Indicates that the task should be executed on a machine with that label, **if possible**.
    - If the machine is not available, a machine without that label may be used.
- `must`:
    - Indicates that the task **must be executed** only on a machine with that label.
    - If a machine with that label does not exist, the Run will not proceed.

> **Advanced Note**
>
> This value is used as a combination of Kubernetes `torelation` and node affinity.
>
> - Labels specified in `may` become `torelation` (`NoSchedule`).
> - Labels specified in `prefer` become `torelation` (`NoSchedule` + `PreferNoSchedule`) and node affinity (`preferredDuringSchedulingIgnoredDuringExecution`).
> - Labels specified in `must` become `torelation` (`NoSchedule` + `PreferNoSchedule`) and node affinity (`requiredDuringSchedulingIgnoredDuringExecution`).
>
> In order for these specifications to work effectively, the Kubernetes cluster needs to be properly configured by the administrator.
>

### Check Plan Definitions

You can check the registered Plan definitions with the following command:

```
knit plan show PLAN_ID
```

To get detailed information about a specific Plan, you need to specify the ID of the Plan you want to know about in place of `PLAN_ID`.
If the specified Plan exists, you will receive console output similar to the following:

```json

{
    "planId": "6dbfed46-f9fb-4e4e-aadd-2a5c42d26913",
    "image": "localhost:30503/Knitfab-first-validation:v1.0",
    "inputs": [
        {
            "path": "/in/dataset",
            "tags": [
                "mode:test",
                "project:first-Knitfab",
                "type:dataset"
            ]
        },
        {
            "path": "/in/model",
            "tags": [
                "project:first-Knitfab",
                "type:model"
            ]
        }
    ],
    "outputs": [],
    "log": {
        "Tags": [
            "project:first-Knitfab",
            "type:log",
            "type:validation"
        ]
    },
    "active": true,
    "resources": {
        "cpu": "1",
        "memory": "1Gi"
    }
}
```

Apart from the difference between JSON and YAML, the structure of a Plan definition is the same.

If you don't know the ID of the Plan you are interested in, you can also search for it.

If you know the image name, you can use the following command:

```
knit plan find --image HOST:PORT/IMAGE:TAG
```

If you know the Tags used in the inputs or outputs, you can use the following:

```
knit plan find --in-tag KEY:VALUE
```

```
knit plan find --out-tag KEY:VALUE
```

If you want to limit the search to active Plans, use the following command:

```
knit plan find --active yes
```

These search conditions can be specified simultaneously, and only the Plans that meet all the conditions will be shown.

Furthermore, `--in-tag` and `--out-tag` can be specified repeatedly, and in that case, the search will only match if there are inputs or outputs that have all the specified "Tags".

When `knit plan find` is executed without any search conditions, it will match all the Plans in the search.

#### Command Line Flags: `knit plan find`

- `--active MODE`: Limits the search to Plans that are active (or inactive).
    - The following values can be specified for MODE:
        - `both` (default): Does not consider the active status as a condition.
        - `yes`, `true`: Searches only for active Plans.
        - `no`, `false`: Searches only for inactive Plans.
- `--image IMAGE[:TAG]`: Searches based on the image of the Plan.
    - `TAG` can be omitted. In that case, the search ignores the tags of the image.
    - The `IMAGE` part also matches the hostname or port of the registered image in the Plan definition. It does not perform partial matching.
- `-i KEY:VALUE`, `--in-tag KEY:VALUE`: Limits the search to those with inputs that have the specified Tags.
    - If this flag is specified multiple times, it only searches for those with inputs that have all the specified Tags.
- `-o KEY:VALUE`, `--out-tag KEY:VALUE`: Limits the search to those with outputs that have the specified Tags.
    - If this flag is specified multiple times, it only searches for those with outputs that have all the specified Tags".

### Activating and deactivating a Plan

If you no longer need a Plan, you can deactivate it:

```
knit plan active no PLAN_ID
```

By executing this command, the Plan identified by the specified `PLAN_ID` will be deactivated.
Any Run based on this Plan that has not started yet will be prevented from executing.

You can also reactivate a Plan that was deactivated for some reason.

```
knit plan active yes PLAN_ID
```

This command will re-execute any prevented Run based on the Plan with the specified `PLAN_ID`.

### Updating the compute resources required by a Plan

Let's say you have executed a computational task and found that there is an excess or shortage of compute resources specified in the Plan definition. This can be a problem, especially if there is a shortage of resources, as the computation cannot be executed.

In such cases, you can update the compute resources specified in the Plan.

For example, if you need "10GiB of memory", you can do the following:

```
knit plan resource --set memory=10Gi
```

If you want to speed up the computation by setting the CPU to 4 cores, use the following command:

```
knit plan resource --set cpu=4
```

Generally,

```
knit plan resource --set TYPE=QUANTITY
```

can specify the required amount for each type of compute resource.

You can also remove constraints on unnecessary compute resources using `--unset`.

If you no longer need the GPU, use the following command:

```
knit plan resource --unset gpu
```

However, even if you use `--unset cpu` or `--unset memory`, it will fallback to the default values of 1 core / 1GiB.

Managing Runs
----

A Run is created from a combination of a Plan and Data.

Users do not directly create Runs. It is generally the responsibility of Knitfab to create Runs, start computations, and detect completion.
A Run launches a container called a worker in the background. The actual computational task is executed inside the worker container.

In this chapter, we will discuss the handling of such Runs.

### Lifecycle of a Run

A Run involves actual computation. Therefore, it has a series of lifecycle stages: "preparing for computation, starting computation, and completing computation".
Before diving into the details of a Run, let's discuss its lifecycle.

```mermaid
stateDiagram-v2
    direction LR

    [*] --> deactivated:  Created\n(from an inactive Plan)
    [*] --> waiting:  Created\n(from an active Plan)

    Generated: Immediately after creation
    state Generated {
        waiting --> deactivated:  Plan is deactivated
        deactivated --> waiting:  Plan is activated
    }

    WithOutput: Output data is secured
    state WithOutput {
        ready

        WithWorker: Worker exists
        state WithWorker {
            starting running completing aborting
        }

        Terminated: Worker deleted
        state Terminated {
            done failed
        }
    }

    Invalidated: Output has been deleted as well
    state Invalidated { invalidated }

    waiting --> ready: Assigned output PVC
    ready --> starting: Registered worker container
    starting --> running: Confirmed worker container startup
    running --> completing: Confirmed successful completion
    running --> aborting: Detected failure or interruption
    starting --> aborting: Detected failure or interruption
    ready --> aborting: Detected failure or interruption

    completing --> done: Worker container deletion
    aborting --> failed: Worker container deletion

    Generated --> invalidated:  Invalidated
    Terminated --> invalidated:  Invalidated

    Terminated --> waiting: Retry\n(= Discard output and return)
    invalidated --> [*]: Upstream Run has been deleted
```

A Run follows the lifecycle depicted in this state transition diagram.

- `waiting`, `deactivated`: Initial states of a Run.
    - Knitfab generates a new Run in the following cases:
        - All inputs of the Plan have been assigned with Data.
        - No existing Run has been executed with that combination of inputs and Data.
- `ready`, `starting`: Preparing to start the computation of the Run and in the process of starting it.
    - When preparation is complete, it transitions to `ready`, and then attempts to start the container, transitioning to `starting`.
- `running`: The computation is actively progressing.
- `aborting`, `failed`: The computation has failed.
    - When a failure is detected, it transitions to `aborting`, and once the container is removed, it transitions to `failed`.
- `completing`, `done`: The computation has succeeded.
    - When successful completion is detected, it transitions to `completing`, and once the container is removed, it transitions to `done`.
    - **Only the data outputted from a Run in this state can be used as input by other Runs.**
- `invalidated`: An internal state used by Knitfab for management purposes. Users will not encounter a Run in this state.

The success of a Run is determined by the exit status of the user-defined container.
If the exit status is `0`, it is considered successful; otherwise, it is considered a failure.

> If a task is implemented in a Python script and an exception is raised, causing the program to stop, the program is considered to have failed.

### Searching for Runs

You can search for Runs within Knitfab using the `run find` command.

For example, if you want to find information about ongoing Runs, by executing:

```
knit run find -s ready -s starting -s running -s completing -s aborting
```

you can only see the active Run states.
`-s` is an alias for `--status`, and when specified multiple times, it searches for Runs that are in any of the specified states.

The following output is expected:

```json
[
    {
        "runId": "3cb1b091-01ad-41b1-acac-3f042f9df97c",
        "status": "starting",
        "updatedAt": "2024-03-07T06:28:31.59+00:00",
        "plan": {
            "planId": "6dbfed46-f9fb-4e4e-aadd-2a5c42d26913",
            "image": "localhost:30503/Knitfab-first-validation:v1.0"
        },
        "inputs": [
            {
                "path": "/in/dataset",
                "tags": [
                    "mode:test",
                    "project:first-Knitfab",
                    "type:dataset"
                ],
                "knitId": "87038a1d-467c-45d4-9cc7-876473f3fc04"
            },
            {
                "path": "/in/model",
                "tags": [
                    "project:first-Knitfab",
                    "type:model"
                ],
                "knitId": "46173435-d55a-46ae-8300-11560ca371d9"
            }
        ],
        "outputs": [],
        "log": {
            "Tags": [
                "project:first-Knitfab",
                "type:log",
                "type:validation"
            ],
            "knitId": "9bb07d29-ab79-4ec0-a233-ec000e418261"
        }
    }
]
```

> If multiple Runs are found, more elements will be in an array.

- `runId`: The ID that identifies this Run.
- `updatedAt`: The timestamp when the state changes of this Run were last detected.
- `status`: The status of this Run.
- `plan`: An overview of the Plan that generated this Run.
- `inputs`, `outputs`, `log`: The actual inputs, outputs, and log of this Run.
    - `knitId` is the specific ID assigned to the Data.
    - `tags` are the Tags of the inputs, outputs, or log (not the Tags of the Data).

Additional information is included for a stopped Run.

```json
{
    "runId": "3cb1b091-01ad-41b1-acac-3f042f9df97c",
    "status": "done",
    "updatedAt": "2024-03-07T06:32:54.791+00:00",
    "exit": {
        "code": 0,
        "message": "Completed"
    },
    "plan": {
        "planId": "6dbfed46-f9fb-4e4e-aadd-2a5c42d26913",
        "image": "localhost:30503/Knitfab-first-validation:v1.0"
    },
    "inputs": [...],
    "outputs": [...],
    "log": {...}
}
```

For a stopped Run, an additional element called `exit` is displayed.
You can read the container's exit code (`code`) and the status at the time of container termination (`message`).


#### コマンドラインフラグ: `knit run find`

You can pass search criteria as command-line flags.

- `-s STATUS`, `--status STATUS`: The status of the Run.
- `-i KNIT_ID`, `--in-knitid KNIT_ID`: The ID of the input Data.
- `-o KNIT_ID`, `--out-knitid KNIT_ID`: The ID of the output Data.
- `-p PLAN_ID`, `--planid PLAN_ID`: The ID of the Plan that generated the Run.

#### Investigating a specific run

If you have identified the ID of a Run, you can use the command `knit run show RUN_ID` to check the information of the Run.

Additionally, by executing `knit run show --log RUN_ID`, you can retrieve the log of that Run if it exists.
Furthermore, by executing `knit run show --log --follow RUN_ID`, you can follow the log of that Run if it exists. This means that new log content will be written to the console whenever a log is generated.

### Stopping and Retrying a Run

Users cannot explicitly create a Run, but users can interrupt a running Run or retry a completed Run.


This functionality is designed for cases where a Run goes out of control and needs to be stopped, or when a Run fails due to unexpected issues during execution and needs to be retried.

#### Stopping a Run

```
knit run stop --fail RUN_ID
```

This command interrupts a Run and forces it to fail. Specifically, it sets the state to `aborting`.

If the `--fail` flag is omitted, the Run is considered to have been interrupted and completed successfully. This is achieved by setting the state to `completing`.

Naturally, you cannot interrupt a Run that is already stopped.

#### Retrying a Run

You can retry a Run that has already stopped and is in a `done` or `failed` state.

```
knit run retry RUN_ID
```

By executing this command,

- Delete the output Data of the Run identified by `RUN_ID`, and
- Reset the state of the Run to `waiting`.

The Run that has been reset to `waiting` will be executed again according to its lifecycle.

A Run that outputs Data used as input of other Runs cannot be retried.
This is an intentional design. By protecting such Runs, the lineage is preserved.

### Deleting a Run

> [!Warning]
>
> This operation is irreversible.

You can delete a Run **only if it is already stopped and there are no other runs downstream**.

```
knit run rm RUN_ID
```

By executing this command, the corresponding Run and its outputs will be deleted. The same combination of inputs and Data will not be executed again.

Lineage
-------

The chain of Runs and Data is called lineage, which is managed by Knitfab.

### Visualizing

There is a feature to export this lineage in graphviz format (dot notation).

In combination with the `dot` command,

```
knit data lineage KNIT_ID | dot -T png -o lineage-graph.png
```

can obtain the lineage of the specified Data with the preceding and following 3 Data  as an image file named `lineage-graph.png`.

#### Command Line Flags

- `-u`: Explore the lineage graph only on the input side (upstream).
- `-d`: Explore the lineage graph only on the output side (downstream).
- `-n int|"all"`: Depth of exploration counted by the number of Data.
    - Default is 3.
    - Specify `all` to explore without limitations.

Guidelines for Tagging
----------------------

Tags can be added to the input and output of Data and Plan.
In terms of specifications, any Tag can be added. The specific usage is left to the user's discretion.

However, as the Knitfab development team, we recommend setting certain Tags.

- `project:...`: The name of the project to which the Data and Plan belong.
    - Prevents unrelated Data from being mixed in.
- `type:...`: Indicates the rough type of the Data.
    - Example: `type:dataset`, `type:hyper-params`, `type:log`, `type:random-seed`, `type:metrics`
- `format:...`: The file format of the Data.
    - Example: `format:mnist`, `format:csv`, `format:text`, `format:png`

Furthermore, Tags can also be used for memos.

- `name:...`: The name of the Data.
    - Especially for uploaded Data.
- `description:...`: Description or summary of the Data.
    - Especially for uploaded Data.

Tags such as `name:...` and `description:...` may not be used for assigning to Plan inputs, but they will help with understanding when looking back with commands like `knit data find`.

Also, it is important to set conditions as Tags to prevent certain types of Data from being accidentally included as inputs.

- `class:...`, `script:...`, `version:...`: (For models and hyperparameters) Class names, scripts, and versions that can be loaded.
- `mode:train`, `mode:validation`, `mode:test`: (For datasets) The purpose of use.
    - Training with test data and evaluating with test data will result in meaningless results.

Extention Command
------------------

Knitfab CLI `knit` recognize Extention Commands.

You can invoke commands prefixed with `knit-` and found in environmental variable `PATH` via `knit`.

> [!NOTE]
>
> The rule convert from command name to subcommand name of `knit`.
>
> 1. Trim prefix `knit-`.
> 2. Trim following suffix, if exits: `.exe`, `.cmd`, `.bat`. `.com`
>
> For example:
>
> - `knit-example` can be invoked as `knit example`
> - `knit-example.exe` also can be invoked as `knit example`
> - `knit-example.exe.something` can be involed as `knit example.exe.someting` (a suffix is trimmed from the last only)
>

On invoking Extention Commands, STDIN, STDOUT and STDERR are passed through from `knit`.
Also all args (except `--profile`, `--profile-store`, `--env`) are passed from `knit` to a Extention Command.

`knit` passes environmental variables and add following:

- `KNIT_PROFILE`: the current Knitfab profile name
- `KNIT_PROFILE_STORE`: the filepath to Knitfab Profile Store

The Profile Store file is a yaml file fomratted as below:

```yaml
PROFILE_NAME:
    apiRoot: https://example.com/knitfab/api
    cert:
        ca: ...
ANOTHER_PROFILE_NAME:
    apiRoot: ...
    cert:
        ca: ...
...
```

This file is structured as a mapping which each keys is a Profile name and its value is a Profile configuration.

Each elements in Profile means:

- `apiRoot`: the root URL of Knitfab Web API
- `cert`: TLS Certification for `apiRoot`
    - `ca`: CA Certificate, BASE64 encoded

The host of `apiRoot` may use a self-signed certification. To request to Knitfab Web API, you may need to trust `cert.ca`.
