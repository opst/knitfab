#! /bin/bash
set -e

HELM=${HELM:-helm}
KUBECTL=${KUBECTL:-kubectl}
OPENSSL=${OPENSSL:-openssl}
REPOSITORY=${REPOSITORY:-opst/knitfab}
IMAGE_REPOSITORY_HOST=${IMAGE_REPOSITORY_HOST:-ghcr.io}
BRANCH=${BRANCH:-main}

CONTENT_ROOT=${CONTENT_ROOT:-"https://raw.githubusercontent.com/${REPOSITORY}/${BRANCH}"}
CHART_REPOSITORY_ROOT=${CHART_REPOSITORY_ROOT:-"${CONTENT_ROOT}/charts/release"}
VERBOSE=${VERBOSE}
THIS=./${0##*/}
HERE=${0%/*}

if [ -z "${CHART_VERSION}" ] ; then
	CHART_VERSION=$(curl -s ${CONTENT_ROOT}/pkg/buildtime/VERSION)
fi

function message() {
	echo -e "$@" >&2
}

function run() {
	if [ -n "${VERBOSE}" ] ; then
		message '$ '"$@"
	else
		message '$ '"${@: 0:3} ... ${@: -2:2}"
	fi

	"$@"
}

function abspath() {
	if [ -d "${1}" ] ; then
		( cd "${1}" && pwd )
	else
		( cd "${1%/*}" && echo "$(pwd)/${1##*/}" )
	fi
}

function get_node_ip() {
	${KUBECTL} get nodes -o jsonpath='{.items[*].status.addresses[?(@.type=="InternalIP")].address}'
}

function prepare_install() {
	mkdir -p "${SETTINGS}/values"
	cd "${SETTINGS}"

	cat <<EOF > ./README.md
knitfab-install-settings/README.md
=================================

This directory is generated by knitfab installer command: \`${THIS} --prepare\`.

In this directory, you can find install settings for knitfab.

  - certs/ca.crt, certs/ca.key, certs/server.crt, certs/server.key
    - Certificate and private key pair of CA and server.
	- If you prepare with --no-tls option, these files are not generated.
  - values/*
    - Install paramters for knitfab.
    - please inspect and set values for your environment. For more details, see values/README.md.
  - kubeconfig
    - Copied kubeconfig file refers to your k8s cluster where Knitfab is going to be installed.
    - Please keep this file secure.
  - namespace
    - Namespace where knitfab is going to be installed.

This directory contains kubeconfig, RDB password and CA key pair.
**KEEP THIS DIRECTORY SECURE**, please be careful to handle this directory.
Permission is set to be read/write by only the owner, you.

Next Step
----------

1. inspect ./knitfab-install-settings/values/ directory and set values for your environment.
    - Especially, you need to invest values/knit-storage-nfs.yaml to persist your data.
    - Other files may be helpful to understand the settings, and you can modify them if needed.
2. ${THIS} --install ... : to install knitfab with your setting.
    - To know options, run "${THIS}" without arguments.
EOF

	cat <<EOF > values/knit-app.yaml
# # # values/knit-app.yaml # # #

# this file declares install paramaters for knit-app.

# # clusterTLD: (optional) Your k8s cluster's top-level domain.
# #  By default, "cluster.local" is used.
# clusterTLD: "cluster.local"

# knitd: api server related settings.
knitd:
  # port: Port number of knit-api service, exposed from k8s cluster node.
  port: 30803

vex:
  # use: If true, vex is deployed. default: false
  use: false

  # # # items below are effective only when vex.use is true. # # #

  # # margin: the minimum size of the volume capacity reminder.
  # margin: 1Gi

  # # delta: the volume growth size for a step.
  # delta: 5Gi

EOF

	cat <<EOF > values/knit-db-postgres.yaml
# # # values/knit-db-postgres.yaml # # #

# # this file declares install paramaters for Database of Knitfab.

# # external:
# #   If true (external mode), use external database and In-cluster Database is not installed.
# #   Otherwise (internal mode; default), knitfab employs in-cluster database.
external: false

# # ephemeral:
# #   If true, Storage Backend of Database is not pereistent (located in the database container).
# #   This is useful for testing.
# #   It is effective in internal mode only.
ephemeral: false

# # service: name of the service for the database.
# #
# #   For internal mode, the service named the value is created by this chart. Optional. (default is "database")
# #   For external mode, it should be IP or hostname of the database.
# #
# service: database

credential:
  # # secret: name of secret for database credential.
  # #
  # # For *internal* mode: name of secret for in-cluster database credential.
  # #
  # #   The secret is created by this chart. Optional. (default is "database-credential")
  # #
  # # For *external* mode: secret name maneged outside of Knitfab.
  # #
  # #   The secret must have the following keys:
  # #   - username: username for login to the database.
  # #   - password: password for login to the database.
  # secret: database-credential

  # # username: (optional) Username for the database.
  # #
  # #   It is effective in internal mode only.
  # #   RDB is set up by with this username on the initial install.
  # #   By default, "knit" is used.
  # username: "knit"

  # # password: Password for the database.
  # #
  # #   It is effective in internal mode only.
  # #   RDB is set up by with this password on the initial install.
  # #   This template has random password. Use it as is, or you can use your own password.
  password: "$(head -c 32 /dev/urandom | base64 | tr -d '\r\n')"

EOF

	cat <<EOF > values/knit-image-registry.yaml
# # # values/knit-image-registry.yaml # # #

# # external: If true, use external registry and In-cluster Registry is not installed.
external: false

# # port: Port number of the registry service, exposed from k8s cluster node.
port: 30503

EOF

	cat <<EOF > values/knit-storage-nfs.yaml
# # # values/knit-storage-nfs.yaml # # #

# # nfs: NFS server related settings.
# #
# # This is the main setting for knitfab to persist your data: how and where.
# #
# #  There are 2 modes: In-Cluster mode and External mode.
# #
# #  * In-Cluster mode (when "external: false", default): knitfab employs in-cluster NFS server.
# #
# #  BY DEFAULT, YOUR DATA WILL BE REMOVED WHEN THE NFS SERVER POD IS REMOVED.
# #
# #  To persist your data,
# #    set "hostPath" to the directory on the node, and
# #    set "node" to the node name where the in-cluster NFS server pod will be scheduled.
# #  Then, your data will be read/written from the "hostPath" on the "node",
# #  and persisted even after the NFS server pod is restarted.
# #
# #  * External mode (when "external: true"): use NFS server you own. (You need your own NFS server)
# #
# #  To use this mode, connection parameters to your NFS server are needed.
# #    set "server" to the hostname of the nfs server, and
# #    set "share" and "mountOptions" if needed.
# #  In this mode, your data will be read/written from your NFS server, and parsisted even after the NFS server pod is restarted.
nfs:
  # # external: If true (External mode), use NFS server you own.
  # #  Otherwise(In-cluster mode), knitfab employs in-cluster NFS server.
  external: false

  # # mountOptions: (optional) Mount options for the nfs server.
  # #  By default, "nfsvers=4.1,rsize=8192,wsize=8192,hard,nolock".
  # mountOptions: "nfsvers=4.1,rsize=8192,wsize=8192,hard,nolock"

  # # share: (optional) Export root of the nfs server. default is "/".
  # share: "/"

  # # # FOR EXTERNAL MODE # # #

  # # server: Hostname of the nfs server.
  # #  If external is true, this value is required.
  # server: "nfs.example.com"

  # # # FOR IN-CLUSTER MODE # # #

  # # hostPath: (optional) Effective only when external is false.
  # # If set, the in-cluster NFS server will read/write files at this directory ON NODE.
  # #
  # # This is useful when you want to keep the data even after the NFS server is restarted.
  # hostPath: "/var/lib/knitfab"

  # # node: (optional) kubernetes node name where the in-cluster NFS server pod should be scheduled.
  # #
  # # by default, the pod will be scheduled to the indeterminated node,
  # # so restarting pod may cause data loss in multinode cluster.
  # #
  # # This value is effective only when "external: false".
  node: ""
EOF

    cat <<EOF > values/hooks.yaml
# # # values/hooks.yaml # # #

# # hooks: webhooks settings for Knitfab.
hooks:

  # # lifecycle-hooks: lifecycle webhooks for Knitfab.
  # #
  # # Each URLs reveices POST requests with a Run as JSON, before or after status change of the Run.
  # #
  # # The Run JSON is formatted as same as output of \`knit run show\`.
  lifecycle-hooks:

    # # before: Webhook URLs to be called before the Knitfab changes the status of a Run.
    # #
    # # The webhook receives POST requests with JSON for each Runs whose status is going to be changed.
    # #
    # # When these hook responses non-200 status, the status changing causes an error and will be retried later.
    before: []

    # # before: Webhook URLs to be called after the Knitfab has changed the status of a Run.
    # #
    # # The webhook receives POST requests with JSON for each Runs whose status has been changed.
    # #
    # # Responses from these hooks are ignored.
    after: []

EOF

    cat <<EOF > values/extra-api.yaml
# # # values/extra-api.yaml # # #

extraApi:
  # # endpoints ([{path:..., proxy_to: ...}]): extra API endpoints .
  endpoints: []
  #  - # path, proxy_to: Knitfab proxies requests to the path (and subpath) to proxy_to.
  #    path: /path/to/your/api
  #    proxy_to: "http://your-api-server/api"
  #    # The example above works as follows:
  #    # https://KNITFAB_HOST/path/to/your/api               -> http://your-api-server/api
  #    # https://KNITFAB_HOST/path/to/your/api/sub           -> http://your-api-server/api/sub
  #    # https://KNITFAB_HOST/path/to/your/api/sub/resource  -> http://your-api-server/api/sub/resource
  #    # https://KNITFAB_HOST/path/to/your/api/sub?query     -> http://your-api-server/api/sub?query
  #    # https://KNITFAB_HOST/path/to/your                   -> (404)
  #    #
  #    # For path, "/api" is reserved for Knitfab builtin API.
  #
  # # more extra apis can be added.
  # # - path: ...
  # #   proxy_to: ...

EOF

	if [ -n "${PULL_SECRET}" ] ; then
		${KUBECTL} create secret generic knitfab-regcred \
			--type=kubernetes.io/dockerconfigjson --from-file "${PULL_SECRET}" \
			--dry-run=client -o yaml > ./knit-image-registry-secret.yaml
	fi
}

function drop_certs() {
	rm -f "${SETTINGS}/certs/ca.crt"
	rm -f "${SETTINGS}/certs/ca.key"
	rm -f "${SETTINGS}/certs/server.crt"
	rm -f "${SETTINGS}/certs/server.key"
	message "(TLS certificates are removed)"
}


function renew_certs() {
	mkdir -p ${SETTINGS}/{values,certs}

	CA_CERT_DEST=${SETTINGS}/certs/ca.crt
	CA_KEY_DEST=${SETTINGS}/certs/ca.key
	TLS_CERT_DEST=${SETTINGS}/certs/server.crt
	TLS_KEY_DEST=${SETTINGS}/certs/server.key

	if [ -n "${RENEW_CA}" ] || [ -n "${TLS_CA_KEY}" ] || ! [ -r "${CA_KEY_DEST}" ] ; then
		if [ -n "${TLS_CA_KEY}" ] && [ -r "${TLS_CA_KEY}" ] ; then
			cp "${TLS_CA_KEY}" "${CA_KEY_DEST}"
			message "(CA key copied from ${TLS_CA_KEY})"
		else
			${OPENSSL} genrsa -out "${CA_KEY_DEST}" 4096
			message "(CA key generated)"
		fi
		RENEW_CERTS=1
	fi

	if [ -n "${RENEW_CA}" ] || [ -n "${TLS_CA_CERT}" ] || ! [ -r "${CA_CERT_DEST}" ] ; then
		if [ -n "${TLS_CA_CERT}" ] && [ -r "${TLS_CA_CERT}" ] ; then
			cp "${TLS_CA_CERT}" "${CA_CERT_DEST}"
			message "(CA certificate copied from ${TLS_CA_CERT})"
		else
			${OPENSSL} req -new -x509 -nodes \
				-key "${CA_KEY_DEST}" \
				-sha256 -days 3650 \
				-out "${CA_CERT_DEST}" \
				-subj "/CN=knitfab/O=knitfab/OU=knitfab"
			message "(Self-signed CA certificate generated)"
		fi
		RENEW_CERTS=1
	fi

	if [ -n "${RENEW_CERTS}" ] || [ -n "${TLS_KEY}" ]|| ! [ -r "${TLS_KEY_DEST}" ] ; then
		if [ -n "${TLS_KEY}" ] && [ -r "${TLS_KEY}" ] ; then
			cp "${TLS_KEY}" "${TLS_KEY_DEST}"
			message "(Server key copied from ${TLS_KEY})"
		else
			${OPENSSL} genrsa -out "${TLS_KEY_DEST}" 4096
			message "(Server key generated)"
		fi
	fi

	if [ -n "${RENEW_CERTS}" ] || [ -n "${TLS_CERT}" ] || ! [ -r "${TLS_CERT_DEST}" ] ; then

		if [ -n "${TLS_CERT}" ] && [ -r "${TLS_CERT}" ] ; then
			cp "${TLS_CERT}" "${TLS_CERT_DEST}"
			message "(Server certificate copied from ${TLS_CERT})"
		else

			function alt_names() {
				local DNS=()
				for NAME in $(get_node_ip) ; do
					COUNT=$((COUNT + 1))
					echo "IP.${COUNT} = ${NAME}"
				done
			}

			cat <<EOF > "${SETTINGS}/certs/san.extfile"
[req]
distinguished_name = req_distinguished_name
req_extensions = req_ext
prompt = no

[req_distinguished_name]
CN = knitfab

[ req_ext ]
subjectAltName = @alt_names

[ SAN ]
subjectAltName = @alt_names
basicConstraints=CA:FALSE

[ v3_ext ]
authorityKeyIdentifier=keyid,issuer:always
basicConstraints=CA:FALSE
keyUsage=keyEncipherment,dataEncipherment,digitalSignature
extendedKeyUsage=serverAuth,clientAuth
subjectAltName=@alt_names

[alt_names]
$(alt_names)
EOF

			# create server CSR
			${OPENSSL} req -new \
				-key ${TLS_KEY_DEST} -out "${SETTINGS}/certs/server.csr" -config "${SETTINGS}/certs/san.extfile"

			# create server certificate
			${OPENSSL} x509 -req -in "${SETTINGS}/certs/server.csr" \
				-CA "${CA_CERT_DEST}" -CAkey "${CA_KEY_DEST}" -CAcreateserial \
				-out "${SETTINGS}/certs/server.crt" \
				-extensions v3_ext -extfile "${SETTINGS}/certs/san.extfile" \
				-days 3650 -sha256

			message "Server Cetificates is generated."
			message ""
		fi
	fi
}

function update_cert_values() {
	: > "${SETTINGS}/values/knit-certs.yaml"
	chmod go-rwx "${SETTINGS}/values/knit-certs.yaml"

	cat <<EOF > "${SETTINGS}/values/knit-certs.yaml"
# # # values/knit-certs.yaml # # #
EOF

	if [ -f "${SETTINGS}/certs/ca.crt" ] && [ -f "${SETTINGS}/certs/ca.key" ] ; then
		cat <<EOF >> "${SETTINGS}/values/knit-certs.yaml"
cacert: $(cat "${SETTINGS}/certs/ca.crt" | base64 | tr -d '\r\n')
cakey: $(cat "${SETTINGS}/certs/ca.key" | base64 | tr -d '\r\n')
EOF
fi

	if [ -f "${SETTINGS}/certs/server.crt" ] && [ -f "${SETTINGS}/certs/server.key" ] ; then
		cat <<EOF >> "${SETTINGS}/values/knit-certs.yaml"
cert: $(cat "${SETTINGS}/certs/server.crt" | base64 | tr -d '\r\n')
key: $(cat "${SETTINGS}/certs/server.key" | base64 | tr -d '\r\n')
EOF
	fi
}

function generate_handouts() {

	mkdir -p "${SETTINGS}/handouts"
	cat <<EOF > "${SETTINGS}/handouts/README.md"
handouts/README.md
=================

This directory contains resources to connect your knitfab.

  - README.md
    - This file.

  - knitprofile
    - knit profile file.
    - pass this file to your knit client in your project directory: \`knit init knitprofile\`

  - docker/certs.d/*
    - CA certificate of the in-cluster image registry.
    - copy this directory to your docker configure directory (\`/etc/docker/certs.d\`, for example)
    - for more detail, see https://docs.docker.com/engine/security/certificates/
EOF

	for IP in $(get_node_ip) ; do
		if [ -f "${SETTINGS}/certs/ca.crt" ] ; then
			cat <<EOF > "${SETTINGS}/handouts/knitprofile"
# knit profile file
# pass this file to your knit client in your project directory: \`knit init knitprofile\`
apiRoot: https://${IP}:$(${KUBECTL} -n ${NAMESPACE} get service/knitd -o jsonpath="{.spec.ports[?(@.name==\"knitd\")].nodePort}")/api
cert:
  ca: $(cat "${SETTINGS}/certs/ca.crt" | base64 | tr -d '\r\n')
EOF
		else
			cat <<EOF > "${SETTINGS}/handouts/knitprofile"
# knit profile file
# pass this file to your knit client in your project directory: \`knit init knitprofile\`
apiRoot: http://${IP}:$(${KUBECTL} -n ${NAMESPACE} get service/knitd -o jsonpath="{.spec.ports[?(@.name==\"knitd\")].nodePort}")/api
cert: {}
EOF
		fi

		DOCKER_CERT_D="${SETTINGS}/handouts/docker/certs.d/${IP}:"$(${KUBECTL} -n ${NAMESPACE} get service/image-registry -o jsonpath="{.spec.ports[?(@.name==\"image-registry\")].nodePort}")
		mkdir -p "${DOCKER_CERT_D}"
		if [ -f "${SETTINGS}/certs/ca.crt" ] ; then
			cp "${SETTINGS}/certs/ca.crt" "${DOCKER_CERT_D}/ca.crt"
		fi

		break  # pick one IP
	done
}

function install() {

	VALUES=${SETTINGS}/values

	if ! [ -r "${KUBECONFIG}" ] ; then
		message "ERROR: KUBECONFIG file not found: ${KUBECONFIG}"
		exit 1
	fi
	echo kubeconfig = ${KUBECONFIG}

	if [ -r "${SETTINGS}/knit-image-registry-secret.yaml" ] ; then
		${KUBECTL} apply -n ${NAMESPACE} -f "${SETTINGS}/knit-image-registry-secret.yaml"
		SET_PULL_SECRET='--set imagePullSecret=knitfab-regcred'
	fi

	message "[1 / 3] addding helm repositories..."

	run ${HELM} repo add --force-update knitfab ${CHART_REPOSITORY_ROOT}

	message "[2 / 3] install knit middlewares..."

	message "[2 / 3] #1 install storage driver"
	run ${HELM} upgrade -i --dependency-update --wait \
		-n ${NAMESPACE} --create-namespace \
		--version ${CHART_VERSION} \
		-f "${VALUES}/knit-storage-nfs.yaml" \
	knit-storage-nfs knitfab/knit-storage-nfs
	sleep 5

	message "[2 / 3] #2 install tls certificates"
	run ${HELM} upgrade -i --dependency-update --wait \
		-n ${NAMESPACE} --create-namespace \
		--version ${CHART_VERSION} \
		-f "${VALUES}/knit-certs.yaml" \
		knit-certs knitfab/knit-certs

	message "[2 / 3] #3 install database"
	run ${HELM} upgrade -i --dependency-update --wait \
		-n ${NAMESPACE} --create-namespace \
		--version ${CHART_VERSION} \
		--set-json "storage=$(${HELM} get values knit-storage-nfs -n ${NAMESPACE} -o json --all)" \
		-f "${VALUES}/knit-db-postgres.yaml" \
		knit-db-postgres knitfab/knit-db-postgres

	message "[2 / 3] #4 install image registry"
	run ${HELM} upgrade -i --dependency-update --wait \
		-n ${NAMESPACE} --create-namespace \
		--version ${CHART_VERSION} \
		--set-json "storage=$(${HELM} get values knit-storage-nfs -n ${NAMESPACE} -o json --all)" \
		--set-json "certs=$(${HELM} get values knit-certs -n ${NAMESPACE} -o json --all)" \
		-f "${VALUES}/knit-image-registry.yaml" \
		knit-image-registry knitfab/knit-image-registry

	message "[3 / 3] install Knitfab app"
	message "[3 / 3] #1 run database upgrade job"
	run ${HELM} upgrade -i --wait \
		-n ${NAMESPACE} --create-namespace \
		--version ${CHART_VERSION} \
		--set-json "storage=$(${HELM} get values knit-storage-nfs -n ${NAMESPACE} -o json --all)" \
		--set-json "database=$(${HELM} get values knit-db-postgres -n ${NAMESPACE} -o json --all)" \
		--set "imageRepository=${IMAGE_REPOSITORY_HOST}/${REPOSITORY}" \
		knit-schema-upgrader knitfab/knit-schema-upgrader

	message "[3 / 3] #2 install knit app"
	run ${HELM} upgrade -i --dependency-update --wait \
		-n ${NAMESPACE} --create-namespace \
		--version ${CHART_VERSION} \
		--set-json "storage=$(${HELM} get values knit-storage-nfs -n ${NAMESPACE} -o json --all)" \
		--set-json "database=$(${HELM} get values knit-db-postgres -n ${NAMESPACE} -o json --all)" \
		--set-json "certs=$(${HELM} get values knit-certs -n ${NAMESPACE} -o json --all)" \
		-f <(${HELM} get values knit-schema-upgrader -n ${NAMESPACE} -o json --all) \
		--set "imageRepository=${IMAGE_REPOSITORY_HOST}/${REPOSITORY}" \
		-f "${VALUES}/knit-app.yaml" \
		-f "${VALUES}/hooks.yaml" \
		-f "${VALUES}/extra-api.yaml" \
		${SET_PULL_SECRET} knit-app knitfab/knit-app
}

function uninstaller() {
	cat <<EOF > "${SETTINGS}/uninstaller.sh"
#! /bin/bash
set -e

# Knitfab Uninstaller

export KUBECONFIG="\${KUBECONFIG:-${KUBECONFIG}}"
JQ=\${JQ:-jq}

if [ "\$1" == "--hard" ] ; then
	echo "" >&2
	echo "** --hard uninstall **" >&2
	echo "" >&2
	echo "This will remove all data in the database and the image registry." >&2
	read -p "Are you sure? [y/N] " ANSWER
	if [ "\${ANSWER}" == "y" ] ; then
		:
	else
		echo "Canceled." >&2
		exit 1
	fi
	HARD=1
fi

${HELM} uninstall -n ${NAMESPACE} knit-app || :
${HELM} uninstall -n ${NAMESPACE} knit-schema-upgrader || :

if [ -z "\${HARD}" ] ; then
	echo "knit-app and knit-schema-upgrader is uninstalled." >&2
	echo "To remove other components and Data, run this script with --hard option." >&2
	exit 0
fi

if ${HELM} status -n ${NAMESPACE} knit-db-postgres > /dev/null 2> /dev/null ; then
	EXTERNAL=
	if [ "true" = \$(${HELM} get values -n ${NAMESPACE} knit-db-postgres -o json --all | \${JQ} -r '.external') ] ; then
		EXTERNAL=1
	fi

	if [ -z "\${EXTERNAL}" ] ; then
		DATABASE_COMPONENT=\$(${HELM} get values -n ${NAMESPACE} knit-db-postgres -o json --all | \${JQ} -r '.component')
		PVC="\${DATABASE_COMPONENT}-pgdata"
		PV=\$(${KUBECTL} -n ${NAMESPACE} get pvc \${PVC} -o json | \${JQ} -r '.spec.volumeName')
	fi

	${HELM} uninstall -n ${NAMESPACE} knit-db-postgres || :

	if [ -z "\${EXTERNAL}" ] ; then
		${KUBECTL} wait -n ${NAMESPACE} --for=delete pvc \${PVC} --timeout=-1s
		${KUBECTL} wait -n ${NAMESPACE} --for=delete pv \${PV} --timeout=-1s
	fi
fi

if ${HELM} status -n ${NAMESPACE} knit-image-registry > /dev/null 2> /dev/null ; then
	IMREG_COMPONENT=\$(${HELM} get values -n ${NAMESPACE} knit-image-registry -o json --all | \${JQ} -r '.component')

	PVC="\${IMREG_COMPONENT}-registry-root"
	PV=\$(${KUBECTL} -n ${NAMESPACE} get pvc \${PVC} -o json | \${JQ} -r '.spec.volumeName')

	${HELM} uninstall -n ${NAMESPACE} knit-image-registry || :

	${KUBECTL} wait -n ${NAMESPACE} --for=delete pvc \${PVC} --timeout=-1s
	${KUBECTL} wait -n ${NAMESPACE} --for=delete pv \${PV} --timeout=-1s
fi

${HELM} uninstall -n ${NAMESPACE} knit-certs || :

STORAGE_CLASS_DATA=\$(${HELM} get values -n ${NAMESPACE} knit-storage-nfs -o json --all | \${JQ} -r '.class.data')
for PVC in \$(${KUBECTL} -n ${NAMESPACE} get pvc -o json | \${JQ} -r ".items[] | select(.spec.storageClassName == \\"\${STORAGE_CLASS_DATA}\\") | .metadata.name") ; do
	${KUBECTL} delete -n ${NAMESPACE} pvc --wait \${PVC}
done
${HELM} uninstall -n ${NAMESPACE} knit-storage-nfs || :
EOF

chmod +x "${SETTINGS}/uninstaller.sh"

}


#
#
# main routine
#
#

USAGE=1
while [ 0 -lt ${#} ] ; do
	ARG=${1}; shift || :
	case ${ARG} in
		--settings|-s)
			SETTINGS=${1}; shift || :
			;;

		--prepare)
			ACTION_PREPARE=1
			ACTION_RENEW_CERTS=1
			ACTION_UPDATE_CERT_VALUES=1

			USAGE=
			;;
		--renew-certs)
			ACTION_RENEW_CERTS=1
			ACTION_UPDATE_CERT_VALUES=1

			RENEW_CERTS=1
			USAGE=
			;;
		--install)
			ACTION_INSTALL=1
			ACTION_UNINSTALLER=1
			USAGE=
			;;
		--uninstaller)
			ACTION_UNINSTALLER=1
			USAGE=
			;;

		# knitfab chart version
		--chart-version)
			CHART_VERSION=${1}; shift || :
			;;
		# CA Certificates
		--tls-ca-cert)
			TLS_CA_CERT=${1}; shift || :
			;;
		--tls-ca-key)
			TLS_CA_KEY=${1}; shift || :
			;;
		# Server Certificates
		--tls-cert)
			TLS_CERT=${1}; shift || :
			;;
		--tls-key)
			TLS_KEY=${1}; shift || :
			;;
		# Renew Self-signed CA Certificates
		# This works only with --renew-certs.
		--renew-ca)
			RENEW_CA=1
			;;
		--no-tls)
			ACTION_UPDATE_CERT_VALUES=1

			NO_TLS=1
			;;

		# kubernetes related options
		--kubeconfig)
			KUBECONFIG=${1}; shift || :
			;;
		--namespace|-n)
			NAMESPACE=${1}; shift || :
			;;
		--verbose)
			VERBOSE=1
			;;
		*)
			;;
	esac
done

if [ -n "${USAGE}" ] ; then
	cat <<EOF >&2
knitfab installer
=================

Usage
-------

\`\`\`
# prepare install settings
${THIS} --prepare \\
    [--tls-ca-cert <CA_CERT>] [--tls-ca-key <CA_KEY>] \\
    [--tls-cert <TLS_CERT>] [--tls-key <TLS_KEY>] \\
	[--namespace|-n <NAMESPACE>] \\
    [--kubeconfig <KUBECONFIG>] \\
    [--settings|-s <SETTINGS=${HERE}/knitfab-install-settings>] \\
	[--no-tls]
\`\`\`

* --tls-ca-cert and --tls-ca-key are the CA certificate and key for the Knitfab.
  Optional. If missing, it generates self-signed CA certificate & key.
* --tls-cert and --tls-key are the server certificate and key for the Knitfab.
  Optional. If missing, it generates certificate & key by CA.
* --no-tls is a flag to skip (and remove) generating TLS certificates.
  Optional. If set, other TLS related flags are ignored.
* --settings is the directory where install settings are saved.
  Optional. Default is \`${HERE}/knitfab-install-settings\`.
* --kubeconfig is the path to the kubeconfig file.
  Optional. Default is ~/.kube/config.
  This file is copied as \$\{--settings\}/kubeconfig.
* --namespace is the namespace where knitfab is installed.
  Optional. Default is "knitfab".
  This value is saved in \$\{--settings\}/namespace.
* --no-tls is a flag to skip generating TLS certificates and remove existing certificates.
  Optional.

\`\`\`
# install or upgrade Knitfab
${THIS} --install \\
    [--settings|-s <SETTINGS>] \\
    [--chart-version <VERSION>] \\
    [--namespace|-n <NAMESPACE>] \\
    [--kubeconfig <KUBECONFIG>]
\`\`\`

* --chart-version is the version of Knitfab chart.
  Optional. Default is the latest version.
* --settings is the directory where install settings are saved.
  Optional. Default is \`${HERE}/knitfab-install-settings\`.
* --namespace is the namespace where Knitfab is installed.
  Optinal. Default is content of \`\$\{--settings\}/namespace\`.
  This value is saved in the settings directory.
* --kubeconfig is the path to the kubeconfig file.
  Optional. Default is \`\$\{--settings\}/kubeconfig\`.
  This file is copied to the settings directory.

This mode implies \`--uninstaller\`.

\`\`\`
# generate uninstaller for Knitfab
${THIS} --uninstaller \\
    [--settings|-s <SETTINGS>]
\`\`\`

* --settings is the directory where uninstaller (\`uninstaller.sh\`) are saved.
  Optional. Default is \`./knitfab-install-settings\`.

\`\`\`
# renew TLS certificates
${THIS} --renew-certs \\
    [--settings|-s <SETTINGS>] \\
    [--renew-ca] \\
	[--no-tls] \\
    [--tls-ca-cert <CA_CERT>] [--tls-ca-key <CA_KEY>] \\
    [--tls-cert <TLS_CERT>] [--tls-key <TLS_KEY>]
\`\`\`

This mode renews TLS (server) certificates.

* --settings is the directory where install settings are saved.
  Optional. Default is \`${HERE}/knitfab-install-settings\`.
* --tls-ca-cert and --tls-ca-key are the CA certificate and key for the Knitfab.
  Optional. If missing, it generates self-signed CA certificate & key.
* --tls-cert and --tls-key are the server certificate and key for the Knitfab.
  Optional. If missing, it generates certificate & key by CA.
* --renew-ca is a flag to force renewing CA certificate & key.
  Optional. If set, CA certificate & key are also renewed (newly generated).
* --no-tls is a flag to skip generating TLS certificates and remove existing certificates.
  Optional.

This mode may be useful when your (CA) certificates are expired.
This mode DOES NOT imply \`--install\`. To apply the renewed certificates, run \`--install\`.

Steps
-----

1. \`./installer.sh --prepare ...\`: to generate templates of knitfab install parameters.
2. inspect \`--settings\` directory and update files for your environment.
  - default is \`./knitfab-install-settings\`
3. \`./installer.sh --install ...\`  to install Knitfab with your setting.

### Next Step

Do \`./installer.sh --prepare ...\`. It generates configuration files of Knitfab installing
EOF
	exit 1
fi


if [ -z "${SETTINGS}" ] ; then
	SETTINGS=${HERE}/knitfab-install-settings
fi
export SETTINGS=$(abspath "${SETTINGS}")
mkdir -p ${SETTINGS}


if [ -z "${NAMESPACE}" ] ; then
	if [ -r "${SETTINGS}/namespace" ] ; then
		NAMESPACE=$(cat "${SETTINGS}/namespace")
	fi
fi
export NAMESPACE=${NAMESPACE:-knitfab}
echo ${NAMESPACE} > "${SETTINGS}/namespace"


if [ -n "${KUBECONFIG}" ] ; then
	cp "${KUBECONFIG}" "${SETTINGS}/kubeconfig"
elif [ -r "${SETTINGS}/kubeconfig" ] ; then
	:
elif [ -r ~/.kube/config ] ; then
	cp ~/.kube/config "${SETTINGS}/kubeconfig"
else
	message "ERROR: KUBECONFIG file not found."
	exit 1
fi
export KUBECONFIG="${SETTINGS}/kubeconfig"

# # # Parameter Validation & Normalization # # #

if [ -n "${TLS_CA_CERT}" ] ; then
	if [ -n "${NO_TLS}" ] ; then
		message "ERROR: --no-tls and --tls-ca-cert are exclusive."
		exit 1
	fi
	export TLS_CA_CERT=$(abspath "${TLS_CA_CERT}")
fi
if [ -n "${TLS_CA_KEY}" ] ; then
	if [ -n "${NO_TLS}" ] ; then
		message "ERROR: --no-tls and --tls-ca-key are exclusive."
		exit 1
	fi
	export TLS_CA_KEY=$(abspath "${TLS_CA_KEY}")
fi
if [ -n "${TLS_CERT}" ] ; then
	if [ -n "${NO_TLS}" ] ; then
		message "ERROR: --no-tls and --tls-cert are exclusive."
		exit 1
	fi
	export TLS_CERT=$(abspath "${TLS_CERT}")
fi
if [ -n "${TLS_KEY}" ] ; then
	if [ -n "${NO_TLS}" ] ; then
		message "ERROR: --no-tls and --tls-key are exclusive."
		exit 1
	fi
	export TLS_KEY=$(abspath "${TLS_KEY}")
fi

if [ -n "${NO_TLS}" ] && [ -z "${ACTION_RENEW_CERTS}" ] ; then
	message "ERROR: --no-tls requires --prepare or --renew-certs."
	exit 1
fi

if [ -n "${ACTION_PREPARE}" ] && [ -n "${ACTION_INSTALL}" ] ; then
	message "ERROR: --prepare and --install are exclusive."
	exit 1
fi

if [ -n "${ACTION_UNINSTALLER}" ] && [ -n "${ACTION_PREPARE}" ] ; then
	message "ERROR: --prepare and --uninstaller are exclusive."
	exit 1
fi

# # # Run Installer Actions # # #

if [ -z "${NO_TLS}" ] && [ -n "${ACTION_RENEW_CERTS}" ] ; then
	renew_certs

	if [ -z "${ACTION_INSTALL}" ] && [ -z "${ACTION_PREPARE}" ] ; then
		LAST_MESSAGE=$(cat <<EOF
${LAST_MESSAGE}
* TLS Certifications are renewed in ${SETTINGS}/certs directory.
EOF
)
	fi
fi

if [ -n "${NO_TLS}" ] ; then
	drop_certs

	if [ -z "${ACTION_INSTALL}" ] && [ -z "${ACTION_PREPARE}" ] ; then
		LAST_MESSAGE=$(cat <<EOF
${LAST_MESSAGE}
* TLS Certifications are removed from ${SETTINGS}/certs directory.
EOF
)
	fi
fi

if [ -n "${ACTION_PREPARE}" ] ; then
	prepare_install

	LAST_MESSAGE=$(cat <<EOF
Prepareng for knitfab installation is done.

✔ 1. ${THIS} --prepare : to generate templates of knitfab install parameters.

Nest Steps
-----

  2. inspect ${SETTINGS}/values/ directory and set values for your environment.
    - Follow README.
    - There are settings for your data to be persistent.
      - Please inspect and set them. Or, you may loss your data by restarting knitfab pods.
  3. ${THIS} --install ... : to install knitfab with your setting.
    - To know options, run "${THIS}" without arguments.

NOTE
-----

* The directory "${SETTINGS}" contains kubeconfig, RDB password ${NO_TLS:-, CA key pair}.
  **KEEP THE DIRECTORY SECURE**, please be careful to handle this directory.
  Permission is set to be read/write by the owner only.

${LAST_MESSAGE}
EOF
)
fi

if [ -n "${ACTION_UPDATE_CERT_VALUES}" ] ; then
	update_cert_values

	if [ -z "${ACTION_INSTALL}" ] && [ -z "${ACTION_PREPARE}" ] ; then
		LAST_MESSAGE=$(cat <<EOF
${LAST_MESSAGE}
* TLS Certifications are updated in ${SETTINGS}/values/knit-certs.yaml .
  - To apply the renewed certificates, run ${THIS} --install ... .
EOF
		)
	fi
fi

if [ -n "${ACTION_UNINSTALLER}" ] ; then
	uninstaller

	LAST_MESSAGE=$(cat <<EOF
${LAST_MESSAGE}
* Uninstaller is generated at ${SETTINGS}/uninstaller.sh .
  - To uninstall knitfab, run this script.
EOF
)
fi

if [ -n "${ACTION_INSTALL}" ] ; then
	install
	generate_handouts

	LAST_MESSAGE=$(cat <<EOF

Install has been done!

---
* Handouts for your user is generated at ${SETTINGS}/handouts .
  - For the initial installation or if CA Certificaion is renewed, distribute new handouts for your user.
${LAST_MESSAGE}
EOF
	)
fi


cat <<EOF >&2
${LAST_MESSAGE}
EOF
